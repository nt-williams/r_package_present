---
title: 'Making an R package: getting started and lessons learned'
author: "Nick Williams"
output: 
  html_document: 
    toc: true
    toc_float: true
    css: styles.css
theme: cosmo
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

## A little background

<script async class="speakerdeck-embed" data-id="cd3f287479984f3485bb0bbbc25a0d0f" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>
<div style="margin-bottom:5px"> <strong> <a href="https://speakerdeck.com/ntwilliams/making-an-r-package" title="Making an R Package" target="_blank">Making an R Package</a> </strong> from <strong><a href="https://speakerdeck.com/ntwilliams" target="_blank">Nick Williams</a></strong>. </div><br>

## Creating the initial package

To get setup, we can first check to see if the `devtools` package is installed and if not install it. 

```{r eval = FALSE}
if (!require(devtools)) {
  install.packages("devtools") 
  library(devtools)
} else {
  library(devtools)
}
```

Once we have devtools loaded, we can create the skeleton of the package. This is where you get to decide the most important aspect of your package, it's name. 

In this case, we will name our package *foopkg*. To create the package we call `create_packages()` and specify where to create the project for the package on your computer. 

```{r}
create_package("~/Documents/foopkg")
```

I'm creating project in my "Documents" folder on my computer. If you want to save the package in a different folder just modify the filepath. You should get an output similar to this and a new R project should open up. 

<img src="images/create_pkg.PNG" style="width:75%">

If you use version control, now would also be a good time to create a git repository for your new package (I'm not going to here, but you should really do this if working on a real package). *devtools* is nice and has a function to do just this.

```{r}
use_git()
```

Before we go any further, we should also add a license. Making an R package is a lot of work and it is important to take ownership of what you create. An MIT License is the best way to go if you want other people to be able to use your package and its code with the only restriction that any further distribution of the package also includes the license. 

```{r}
use_mit_license("Your name here")
```

Two new files should be added to your package folder. If you open the .md file you should see a licence identical to this but with your name instead. 

<img src="images/license.PNG" style="width:75%">

## Adding functions

Making a package requires you to have functions within the package to actually use. We won't go over writing functions here, but there are plenty of resources online if you need help. 

The code for package functions should be stored in the R folder. It is good practice to save the file name as the name of the function itself. Once again, *devtools* has a helper function for this. 

```{r}
use_r("fooadd")
```

`use_r` will create a .R file in R/. In this case, the file will be called "fooadd.R" We are also going to manually create a file in R/ called "print.fooadd.R". We can't use `use_r` in this case because the period between print and fooadd will be replaced with a dash; this period is necessary for correct functionality in this case. 

We can now populate the new files with the defining code of the functions. 

```{r}
fooadd <- function(obj, ...) {
  x <- sum(obj, ...)

  out <- list(obj = obj, ..., sum = x)
  class(out) <- "fadd"
  out
}
```

`fooadd` is a simple function that takes two integers as its arguments and returns their sum. However, instead of returning standard R console output, we are are going to utilize the S3 object-oriented program mechanic in R to output some nicer looking output. To do this, we write a function called `print.fadd` which takes as its input the list created when calling `fooadd` and then combines those list elements using `glue`. Now, whenever printing the results of `fooadd`, the function `print` searches through its defined methods and recognizes how to print an object of class "fadd". 

```{r}
print.fadd <- function(x, ...) {

  base <- glue('{x$obj} +')
  y <- x[names(x) == ""]

  for (i in 1:length(y)) {
    if (i < length(y)) {
      base <- glue('{base} {y[[i]]} +')
    } else if (i == length(y)) {
      base <- glue('{base} {y[[i]]}')
    }
  }
  cat(glue('{base} = {x$sum}'))
}
```

This might seem unnecessary, but its important to remember that you should be writing functions that are going to be distributed and used in ways you may not expect. Beyond returning a more user friendly output, creating an S3 method for the generic `print` function allows users to save the results of `fooadd` as an object which can be further manipulated. 

### Piloting

Of course you are going to want to test your function as you go to make sure its working the way you expect it to. Instead of adding the function to your global environment as you might do in a normal R script you should call `load_all()`. 

<img src="images/load_all.PNG" style="width:75%">

If we call this for *foopkg* we can now experiment with `fooadd` in a robust way. 

<img src="images/fooadd.PNG" style="width:75%">

It looks like our function are working!








